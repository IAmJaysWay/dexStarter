import ie from"pino";import{RELAYER_DEFAULT_PROTOCOL as ne,RELAYER_EVENTS as re,EXPIRER_EVENTS as oe,Store as $,Core as ae}from"@walletconnect/core";import{getDefaultLoggerOptions as ce,generateChildLogger as le,getLoggerContext as pe}from"@walletconnect/logger";import{IEngine as he,ISignClient as de}from"@walletconnect/types";import{TYPE_1 as ge,createDelayedPromise as q,engineEvent as p,getInternalError as c,calcExpiry as I,isValidObject as k,getRequiredNamespacesFromNamespaces as we,getSdkError as _,isSessionCompatible as me,isExpired as f,isValidParams as m,isUndefined as X,isValidRequiredNamespaces as ue,isValidRelays as ye,isValidNamespaces as M,isConformingNamespaces as J,isValidString as D,isValidErrorReason as Se,isValidRelay as Ee,isValidController as Ie,isValidNamespacesChainId as H,isValidRequest as _e,isValidNamespacesRequest as Re,isValidRequestExpiry as Ne,isValidResponse as qe,isValidEvent as fe,isValidNamespacesEvent as ve,parseExpirerTarget as Pe,isValidId as Ve,getAppMetadata as Oe}from"@walletconnect/utils";import Te,{EventEmitter as xe}from"events";import{THIRTY_DAYS as De,SEVEN_DAYS as F,FIVE_MINUTES as u,ONE_DAY as v,THIRTY_SECONDS as Q}from"@walletconnect/time";import{isJsonRpcResult as R,isJsonRpcError as N,formatJsonRpcRequest as Ae,formatJsonRpcResult as Ce,formatJsonRpcError as Le,isJsonRpcRequest as be,isJsonRpcResponse as Ge}from"@walletconnect/jsonrpc-utils";const U="wc",K=2,z="client",A=`${U}@${K}:${z}:`,C={name:z,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},$e={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_event:"session_event",proposal_expire:"proposal_expire"},Me={database:":memory:"},Ue={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ke="history",ze="0.3",B="proposal",je=De,Z="session",T=F,W="engine",P={wc_sessionPropose:{req:{ttl:u,prompt:!0,tag:1100},res:{ttl:u,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:u,prompt:!1,tag:1102},res:{ttl:u,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:v,prompt:!1,tag:1104},res:{ttl:v,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:v,prompt:!1,tag:1106},res:{ttl:v,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:u,prompt:!0,tag:1108},res:{ttl:u,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:u,prompt:!0,tag:1110},res:{ttl:u,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:v,prompt:!1,tag:1112},res:{ttl:v,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:Q,prompt:!1,tag:1114},res:{ttl:Q,prompt:!1,tag:1115}}},L={min:u,max:F},ee="request";var Ye=Object.defineProperty,ke=Object.defineProperties,Xe=Object.getOwnPropertyDescriptors,se=Object.getOwnPropertySymbols,Je=Object.prototype.hasOwnProperty,He=Object.prototype.propertyIsEnumerable,te=(h,n,e)=>n in h?Ye(h,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[n]=e,y=(h,n)=>{for(var e in n||(n={}))Je.call(n,e)&&te(h,e,n[e]);if(se)for(var e of se(n))He.call(n,e)&&te(h,e,n[e]);return h},j=(h,n)=>ke(h,Xe(n));class Fe extends he{constructor(n){super(n),this.name=W,this.events=new Te,this.initialized=!1,this.ignoredPayloadTypes=[ge],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.client.core.pairing.register({methods:Object.keys(P)}),this.initialized=!0)},this.connect=async e=>{this.isInitialized(),await this.isValidConnect(e);const{pairingTopic:s,requiredNamespaces:t,relays:i}=e;let r=s,o,a=!1;if(r&&(a=this.client.core.pairing.pairings.get(r).active),!r||!a){const{topic:E,uri:g}=await this.client.core.pairing.create();r=E,o=g}const l=await this.client.core.crypto.generateKeyPair(),d={requiredNamespaces:t,relays:i??[{protocol:ne}],proposer:{publicKey:l,metadata:this.client.metadata}},{reject:S,resolve:w,done:V}=q();if(this.events.once(p("session_connect"),async({error:E,session:g})=>{if(E)S(E);else if(g){g.self.publicKey=l;const O=j(y({},g),{requiredNamespaces:g.requiredNamespaces});await this.client.session.set(g.topic,O),await this.setExpiry(g.topic,g.expiry),r&&await this.client.core.pairing.updateMetadata({topic:r,metadata:g.peer.metadata}),w(O)}}),!r){const{message:E}=c("NO_MATCHING_KEY",`connect() pairing topic: ${r}`);throw new Error(E)}const x=await this.sendRequest(r,"wc_sessionPropose",d),G=I(u);return await this.setProposal(x,y({id:x,expiry:G},d)),{uri:o,approval:V}},this.pair=async e=>(this.isInitialized(),await this.client.core.pairing.pair(e)),this.approve=async e=>{this.isInitialized(),await this.isValidApprove(e);const{id:s,relayProtocol:t,namespaces:i}=e,r=this.client.proposal.get(s);let{pairingTopic:o,proposer:a,requiredNamespaces:l}=r;k(l)||(l=we(i,"approve()"),this.client.proposal.set(s,j(y({},r),{requiredNamespaces:l})));const d=await this.client.core.crypto.generateKeyPair(),S=a.publicKey,w=await this.client.core.crypto.generateSharedKey(d,S),V={relay:{protocol:t??"irn"},namespaces:i,requiredNamespaces:l,controller:{publicKey:d,metadata:this.client.metadata},expiry:I(T)};await this.client.core.relayer.subscribe(w);const x=await this.sendRequest(w,"wc_sessionSettle",V),{done:G,resolve:E,reject:g}=q();this.events.once(p("session_approve",x),({error:Y})=>{Y?g(Y):E(this.client.session.get(w))});const O=j(y({},V),{topic:w,acknowledged:!1,self:V.controller,peer:{publicKey:a.publicKey,metadata:a.metadata},controller:d});return await this.client.session.set(w,O),await this.setExpiry(w,I(T)),o&&await this.client.core.pairing.updateMetadata({topic:o,metadata:O.peer.metadata}),o&&s&&(await this.sendResult(s,o,{relay:{protocol:t??"irn"},responderPublicKey:d}),await this.client.proposal.delete(s,_("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:o})),{topic:w,acknowledged:G}},this.reject=async e=>{this.isInitialized(),await this.isValidReject(e);const{id:s,reason:t}=e,{pairingTopic:i}=this.client.proposal.get(s);i&&(await this.sendError(s,i,t),await this.client.proposal.delete(s,_("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.isValidUpdate(e);const{topic:s,namespaces:t}=e,i=await this.sendRequest(s,"wc_sessionUpdate",{namespaces:t}),{done:r,resolve:o,reject:a}=q();return this.events.once(p("session_update",i),({error:l})=>{l?a(l):o()}),await this.client.session.update(s,{namespaces:t}),{acknowledged:r}},this.extend=async e=>{this.isInitialized(),await this.isValidExtend(e);const{topic:s}=e,t=await this.sendRequest(s,"wc_sessionExtend",{}),{done:i,resolve:r,reject:o}=q();return this.events.once(p("session_extend",t),({error:a})=>{a?o(a):r()}),await this.setExpiry(s,I(T)),{acknowledged:i}},this.request=async e=>{this.isInitialized(),await this.isValidRequest(e);const{chainId:s,request:t,topic:i,expiry:r}=e,o=await this.sendRequest(i,"wc_sessionRequest",{request:t,chainId:s},r),{done:a,resolve:l,reject:d}=q(r);return this.events.once(p("session_request",o),({error:S,result:w})=>{S?d(S):l(w)}),await a()},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:s,response:t}=e,{id:i}=t;R(t)?await this.sendResult(i,s,t.result):N(t)&&await this.sendError(i,s,t.error),this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0})},this.ping=async e=>{this.isInitialized(),await this.isValidPing(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=await this.sendRequest(s,"wc_sessionPing",{}),{done:i,resolve:r,reject:o}=q();this.events.once(p("session_ping",t),({error:a})=>{a?o(a):r()}),await i()}else this.client.core.pairing.pairings.keys.includes(s)&&await this.client.core.pairing.ping({topic:s})},this.emit=async e=>{this.isInitialized(),await this.isValidEmit(e);const{topic:s,event:t,chainId:i}=e;await this.sendRequest(s,"wc_sessionEvent",{event:t,chainId:i})},this.disconnect=async e=>{this.isInitialized(),await this.isValidDisconnect(e);const{topic:s}=e;this.client.session.keys.includes(s)?(await this.sendRequest(s,"wc_sessionDelete",_("USER_DISCONNECTED")),await this.deleteSession(s)):await this.client.core.pairing.disconnect({topic:s})},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(s=>me(s,e))),this.getPendingSessionRequests=()=>(this.isInitialized(),this.client.pendingRequest.getAll()),this.deleteSession=async(e,s)=>{const{self:t}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),await Promise.all([this.client.session.delete(e,_("USER_DISCONNECTED")),this.client.core.crypto.deleteKeyPair(t.publicKey),this.client.core.crypto.deleteSymKey(e),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deleteProposal=async(e,s)=>{await Promise.all([this.client.proposal.delete(e,_("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deletePendingSessionRequest=async(e,s,t=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,s),t?Promise.resolve():this.client.core.expirer.del(e)])},this.setExpiry=async(e,s)=>{this.client.session.keys.includes(e)&&await this.client.session.update(e,{expiry:s}),this.client.core.expirer.set(e,s)},this.setProposal=async(e,s)=>{await this.client.proposal.set(e,s),this.client.core.expirer.set(e,s.expiry)},this.setPendingSessionRequest=async e=>{const s=P.wc_sessionRequest.req.ttl,{id:t,topic:i,params:r}=e;await this.client.pendingRequest.set(t,{id:t,topic:i,params:r}),s&&this.client.core.expirer.set(t,I(s))},this.sendRequest=async(e,s,t,i)=>{const r=Ae(s,t),o=await this.client.core.crypto.encode(e,r),a=P[s].req;return i&&(a.ttl=i),this.client.core.history.set(e,r),this.client.core.relayer.publish(e,o,a),r.id},this.sendResult=async(e,s,t)=>{const i=Ce(e,t),r=await this.client.core.crypto.encode(s,i),o=await this.client.core.history.get(s,e),a=P[o.request.method].res;this.client.core.relayer.publish(s,r,a),await this.client.core.history.resolve(i)},this.sendError=async(e,s,t)=>{const i=Le(e,t),r=await this.client.core.crypto.encode(s,i),o=await this.client.core.history.get(s,e),a=P[o.request.method].res;this.client.core.relayer.publish(s,r,a),await this.client.core.history.resolve(i)},this.cleanup=async()=>{const e=[],s=[];this.client.session.getAll().forEach(t=>{f(t.expiry)&&e.push(t.topic)}),this.client.proposal.getAll().forEach(t=>{f(t.expiry)&&s.push(t.id)}),await Promise.all([...e.map(t=>this.deleteSession(t)),...s.map(t=>this.deleteProposal(t))])},this.onRelayEventRequest=e=>{const{topic:s,payload:t}=e,i=t.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeRequest(s,t);case"wc_sessionSettle":return this.onSessionSettleRequest(s,t);case"wc_sessionUpdate":return this.onSessionUpdateRequest(s,t);case"wc_sessionExtend":return this.onSessionExtendRequest(s,t);case"wc_sessionPing":return this.onSessionPingRequest(s,t);case"wc_sessionDelete":return this.onSessionDeleteRequest(s,t);case"wc_sessionRequest":return this.onSessionRequest(s,t);case"wc_sessionEvent":return this.onSessionEventRequest(s,t);default:return this.client.logger.info(`Unsupported request method ${i}`)}},this.onRelayEventResponse=async e=>{const{topic:s,payload:t}=e,i=(await this.client.core.history.get(s,t.id)).request.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeResponse(s,t);case"wc_sessionSettle":return this.onSessionSettleResponse(s,t);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,t);case"wc_sessionExtend":return this.onSessionExtendResponse(s,t);case"wc_sessionPing":return this.onSessionPingResponse(s,t);case"wc_sessionRequest":return this.onSessionRequestResponse(s,t);default:return this.client.logger.info(`Unsupported response method ${i}`)}},this.onSessionProposeRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidConnect(y({},s.params));const r=I(u),o=y({id:i,pairingTopic:e,expiry:r},t);await this.setProposal(i,o),this.client.events.emit("session_proposal",{id:i,params:o})}catch(r){await this.sendError(i,e,r),this.client.logger.error(r)}},this.onSessionProposeResponse=async(e,s)=>{const{id:t}=s;if(R(s)){const{result:i}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:i});const r=this.client.proposal.get(t);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:r});const o=r.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:o});const a=i.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:a});const l=await this.client.core.crypto.generateSharedKey(o,a);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const d=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:d}),await this.client.core.pairing.activate({topic:e})}else N(s)&&(await this.client.proposal.delete(t,_("USER_DISCONNECTED")),this.events.emit(p("session_connect"),{error:s.error}))},this.onSessionSettleRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidSessionSettleRequest(i);const{relay:r,controller:o,expiry:a,namespaces:l,requiredNamespaces:d}=s.params,S={topic:e,relay:r,expiry:a,namespaces:l,acknowledged:!0,requiredNamespaces:d,controller:o.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}};await this.sendResult(s.id,e,!0),this.events.emit(p("session_connect"),{session:S})}catch(r){await this.sendError(t,e,r),this.client.logger.error(r)}},this.onSessionSettleResponse=async(e,s)=>{const{id:t}=s;R(s)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(p("session_approve",t),{})):N(s)&&(await this.client.session.delete(e,_("USER_DISCONNECTED")),this.events.emit(p("session_approve",t),{error:s.error}))},this.onSessionUpdateRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidUpdate(y({topic:e},t)),await this.client.session.update(e,{namespaces:t.namespaces}),await this.sendResult(i,e,!0),this.client.events.emit("session_update",{id:i,topic:e,params:t})}catch(r){await this.sendError(i,e,r),this.client.logger.error(r)}},this.onSessionUpdateResponse=(e,s)=>{const{id:t}=s;R(s)?this.events.emit(p("session_update",t),{}):N(s)&&this.events.emit(p("session_update",t),{error:s.error})},this.onSessionExtendRequest=async(e,s)=>{const{id:t}=s;try{this.isValidExtend({topic:e}),await this.setExpiry(e,I(T)),await this.sendResult(t,e,!0),this.client.events.emit("session_extend",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionExtendResponse=(e,s)=>{const{id:t}=s;R(s)?this.events.emit(p("session_extend",t),{}):N(s)&&this.events.emit(p("session_extend",t),{error:s.error})},this.onSessionPingRequest=async(e,s)=>{const{id:t}=s;try{this.isValidPing({topic:e}),await this.sendResult(t,e,!0),this.client.events.emit("session_ping",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionPingResponse=(e,s)=>{const{id:t}=s;setTimeout(()=>{R(s)?this.events.emit(p("session_ping",t),{}):N(s)&&this.events.emit(p("session_ping",t),{error:s.error})},500)},this.onSessionDeleteRequest=async(e,s)=>{const{id:t}=s;try{this.isValidDisconnect({topic:e,reason:s.params}),await this.sendResult(t,e,!0),await this.deleteSession(e),this.client.events.emit("session_delete",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidRequest(y({topic:e},i)),await this.setPendingSessionRequest({id:t,topic:e,params:i}),this.client.events.emit("session_request",{id:t,topic:e,params:i})}catch(r){await this.sendError(t,e,r),this.client.logger.error(r)}},this.onSessionRequestResponse=(e,s)=>{const{id:t}=s;R(s)?this.events.emit(p("session_request",t),{result:s.result}):N(s)&&this.events.emit(p("session_request",t),{error:s.error})},this.onSessionEventRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidEmit(y({topic:e},i)),this.client.events.emit("session_event",{id:t,topic:e,params:i})}catch(r){await this.sendError(t,e,r),this.client.logger.error(r)}},this.isValidConnect=async e=>{if(!m(e)){const{message:o}=c("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(o)}const{pairingTopic:s,requiredNamespaces:t,relays:i}=e;if(X(s)||await this.isValidPairingTopic(s),!X(t)&&k(t)===0)return;const r=ue(t,"connect()");if(r)throw new Error(r.message);if(!ye(i,!0)){const{message:o}=c("MISSING_OR_INVALID",`connect() relays: ${i}`);throw new Error(o)}},this.isValidApprove=async e=>{if(!m(e))throw new Error(c("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:s,namespaces:t,relayProtocol:i}=e;await this.isValidProposalId(s);const r=this.client.proposal.get(s),o=M(t,"approve()");if(o)throw new Error(o.message);const a=J(r.requiredNamespaces,t,"update()");if(a)throw new Error(a.message);if(!D(i,!0)){const{message:l}=c("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(l)}},this.isValidReject=async e=>{if(!m(e)){const{message:i}=c("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(i)}const{id:s,reason:t}=e;if(await this.isValidProposalId(s),!Se(t)){const{message:i}=c("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidSessionSettleRequest=e=>{if(!m(e)){const{message:l}=c("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(l)}const{relay:s,controller:t,namespaces:i,expiry:r}=e;if(!Ee(s)){const{message:l}=c("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const o=Ie(t,"onSessionSettleRequest()");if(o)throw new Error(o.message);const a=M(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(f(r)){const{message:l}=c("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async e=>{if(!m(e)){const{message:a}=c("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(a)}const{topic:s,namespaces:t}=e;await this.isValidSessionTopic(s);const i=this.client.session.get(s),r=M(t,"update()");if(r)throw new Error(r.message);const o=J(i.requiredNamespaces,t,"update()");if(o)throw new Error(o.message)},this.isValidExtend=async e=>{if(!m(e)){const{message:t}=c("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionTopic(s)},this.isValidRequest=async e=>{if(!m(e)){const{message:a}=c("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(a)}const{topic:s,request:t,chainId:i,expiry:r}=e;await this.isValidSessionTopic(s);const{namespaces:o}=this.client.session.get(s);if(!H(o,i)){const{message:a}=c("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(a)}if(!_e(t)){const{message:a}=c("MISSING_OR_INVALID",`request() ${JSON.stringify(t)}`);throw new Error(a)}if(!Re(o,i,t.method)){const{message:a}=c("MISSING_OR_INVALID",`request() method: ${t.method}`);throw new Error(a)}if(r&&!Ne(r,L)){const{message:a}=c("MISSING_OR_INVALID",`request() expiry: ${r}. Expiry must be a number (in seconds) between ${L.min} and ${L.max}`);throw new Error(a)}},this.isValidRespond=async e=>{if(!m(e)){const{message:i}=c("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(i)}const{topic:s,response:t}=e;if(await this.isValidSessionTopic(s),!qe(t)){const{message:i}=c("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidPing=async e=>{if(!m(e)){const{message:t}=c("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.isValidEmit=async e=>{if(!m(e)){const{message:o}=c("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(o)}const{topic:s,event:t,chainId:i}=e;await this.isValidSessionTopic(s);const{namespaces:r}=this.client.session.get(s);if(!H(r,i)){const{message:o}=c("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(o)}if(!fe(t)){const{message:o}=c("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}if(!ve(r,i,t.name)){const{message:o}=c("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}},this.isValidDisconnect=async e=>{if(!m(e)){const{message:t}=c("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)}}isInitialized(){if(!this.initialized){const{message:n}=c("NOT_INITIALIZED",this.name);throw new Error(n)}}registerRelayerEvents(){this.client.core.relayer.on(re.message,async n=>{const{topic:e,message:s}=n;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))return;const t=await this.client.core.crypto.decode(e,s);be(t)?(this.client.core.history.set(e,t),this.onRelayEventRequest({topic:e,payload:t})):Ge(t)&&(await this.client.core.history.resolve(t),this.onRelayEventResponse({topic:e,payload:t}))})}registerExpirerEvents(){this.client.core.expirer.on(oe.expired,async n=>{const{topic:e,id:s}=Pe(n.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,c("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession(e,!0),this.client.events.emit("session_expire",{topic:e})):s&&await this.deleteProposal(s,!0)})}isValidPairingTopic(n){if(!D(n,!1)){const{message:e}=c("MISSING_OR_INVALID",`pairing topic should be a string: ${n}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(n)){const{message:e}=c("NO_MATCHING_KEY",`pairing topic doesn't exist: ${n}`);throw new Error(e)}if(f(this.client.core.pairing.pairings.get(n).expiry)){const{message:e}=c("EXPIRED",`pairing topic: ${n}`);throw new Error(e)}}async isValidSessionTopic(n){if(!D(n,!1)){const{message:e}=c("MISSING_OR_INVALID",`session topic should be a string: ${n}`);throw new Error(e)}if(!this.client.session.keys.includes(n)){const{message:e}=c("NO_MATCHING_KEY",`session topic doesn't exist: ${n}`);throw new Error(e)}if(f(this.client.session.get(n).expiry)){await this.deleteSession(n);const{message:e}=c("EXPIRED",`session topic: ${n}`);throw new Error(e)}}async isValidSessionOrPairingTopic(n){if(this.client.session.keys.includes(n))await this.isValidSessionTopic(n);else if(this.client.core.pairing.pairings.keys.includes(n))this.isValidPairingTopic(n);else if(D(n,!1)){const{message:e}=c("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${n}`);throw new Error(e)}else{const{message:e}=c("MISSING_OR_INVALID",`session or pairing topic should be a string: ${n}`);throw new Error(e)}}async isValidProposalId(n){if(!Ve(n)){const{message:e}=c("MISSING_OR_INVALID",`proposal id should be a number: ${n}`);throw new Error(e)}if(!this.client.proposal.keys.includes(n)){const{message:e}=c("NO_MATCHING_KEY",`proposal id doesn't exist: ${n}`);throw new Error(e)}if(f(this.client.proposal.get(n).expiry)){await this.deleteProposal(n);const{message:e}=c("EXPIRED",`proposal id: ${n}`);throw new Error(e)}}}class Qe extends ${constructor(n,e){super(n,e,B,A),this.core=n,this.logger=e}}class Be extends ${constructor(n,e){super(n,e,Z,A),this.core=n,this.logger=e}}class Ze extends ${constructor(n,e){super(n,e,ee,A),this.core=n,this.logger=e}}class b extends de{constructor(n){super(n),this.protocol=U,this.version=K,this.name=C.name,this.events=new xe,this.on=(s,t)=>this.events.on(s,t),this.once=(s,t)=>this.events.once(s,t),this.off=(s,t)=>this.events.off(s,t),this.removeListener=(s,t)=>this.events.removeListener(s,t),this.removeAllListeners=s=>this.events.removeAllListeners(s),this.connect=async s=>{try{return await this.engine.connect(s)}catch(t){throw this.logger.error(t.message),t}},this.pair=async s=>{try{return await this.engine.pair(s)}catch(t){throw this.logger.error(t.message),t}},this.approve=async s=>{try{return await this.engine.approve(s)}catch(t){throw this.logger.error(t.message),t}},this.reject=async s=>{try{return await this.engine.reject(s)}catch(t){throw this.logger.error(t.message),t}},this.update=async s=>{try{return await this.engine.update(s)}catch(t){throw this.logger.error(t.message),t}},this.extend=async s=>{try{return await this.engine.extend(s)}catch(t){throw this.logger.error(t.message),t}},this.request=async s=>{try{return await this.engine.request(s)}catch(t){throw this.logger.error(t.message),t}},this.respond=async s=>{try{return await this.engine.respond(s)}catch(t){throw this.logger.error(t.message),t}},this.ping=async s=>{try{return await this.engine.ping(s)}catch(t){throw this.logger.error(t.message),t}},this.emit=async s=>{try{return await this.engine.emit(s)}catch(t){throw this.logger.error(t.message),t}},this.disconnect=async s=>{try{return await this.engine.disconnect(s)}catch(t){throw this.logger.error(t.message),t}},this.find=s=>{try{return this.engine.find(s)}catch(t){throw this.logger.error(t.message),t}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}},this.name=n?.name||C.name,this.metadata=n?.metadata||Oe();const e=typeof n?.logger<"u"&&typeof n?.logger!="string"?n.logger:ie(ce({level:n?.logger||C.logger}));this.core=n?.core||new ae(n),this.logger=le(e,this.name),this.session=new Be(this.core,this.logger),this.proposal=new Qe(this.core,this.logger),this.pendingRequest=new Ze(this.core,this.logger),this.engine=new Fe(this)}static async init(n){const e=new b(n);return await e.initialize(),e}get context(){return pe(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success")}catch(n){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(n.message),n}}}const We=b;export{W as ENGINE_CONTEXT,P as ENGINE_RPC_OPTS,Ke as HISTORY_CONTEXT,Ue as HISTORY_EVENTS,ze as HISTORY_STORAGE_VERSION,B as PROPOSAL_CONTEXT,je as PROPOSAL_EXPIRY,ee as REQUEST_CONTEXT,Z as SESSION_CONTEXT,T as SESSION_EXPIRY,L as SESSION_REQUEST_EXPIRY_BOUNDARIES,z as SIGN_CLIENT_CONTEXT,C as SIGN_CLIENT_DEFAULT,$e as SIGN_CLIENT_EVENTS,U as SIGN_CLIENT_PROTOCOL,Me as SIGN_CLIENT_STORAGE_OPTIONS,A as SIGN_CLIENT_STORAGE_PREFIX,K as SIGN_CLIENT_VERSION,We as SignClient,b as default};
//# sourceMappingURL=index.es.js.map
