/// <reference types="node" />
import SignClient from "@walletconnect/sign-client";
import { ProviderAccounts } from "eip1193-provider";
import { SessionTypes } from "@walletconnect/types";
import { Logger } from "@walletconnect/logger";
import { IUniversalProvider, RpcProviderMap, ConnectParams, RequestArguments, UniversalProviderOpts, NamespaceConfig } from "./types";
import EventEmitter from "events";
export declare class UniversalProvider implements IUniversalProvider {
    client: SignClient;
    namespaces: NamespaceConfig;
    events: EventEmitter;
    rpcProviders: RpcProviderMap;
    session: SessionTypes.Struct;
    providerOpts: UniversalProviderOpts;
    logger: Logger;
    uri: string | undefined;
    static init(opts: UniversalProviderOpts): Promise<UniversalProvider>;
    constructor(opts: UniversalProviderOpts);
    request<T = unknown>(args: RequestArguments, chain?: string | undefined): Promise<T>;
    sendAsync(args: RequestArguments, callback: (error: Error | null, response: any) => void, chain?: string | undefined): void;
    enable(): Promise<ProviderAccounts>;
    disconnect(): Promise<void>;
    connect(opts: ConnectParams): Promise<SessionTypes.Struct | undefined>;
    on(event: any, listener: any): void;
    once(event: string, listener: any): void;
    removeListener(event: string, listener: any): void;
    off(event: string, listener: any): void;
    get isWalletConnect(): boolean;
    pair(pairingTopic: string | undefined): Promise<SessionTypes.Struct>;
    setDefaultChain(chain: string, rpcUrl?: string | undefined): void;
    cleanupPendingPairings(): Promise<void>;
    private checkStorage;
    private initialize;
    private createClient;
    private createProviders;
    private registerEventListeners;
    private getProvider;
    private onSessionUpdate;
    private setNamespaces;
    private validateChain;
}
export default UniversalProvider;
//# sourceMappingURL=UniversalProvider.d.ts.map