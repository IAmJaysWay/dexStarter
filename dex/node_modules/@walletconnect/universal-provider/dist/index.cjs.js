"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var f=require("pino"),w=require("@walletconnect/sign-client"),h=require("@walletconnect/utils"),P=require("@walletconnect/logger"),p=require("@walletconnect/jsonrpc-provider"),l=require("@walletconnect/jsonrpc-http-connection"),y=require("events");function r(s){return s&&typeof s=="object"&&"default"in s?s:{default:s}}var C=r(f),I=r(w),O=r(l),E=r(y);function q(s){var e;const t=(e=s[Object.keys(s)[0]])==null?void 0:e.chains[0];return[t.split(":")[0],t.split(":")[1]]}function a(s,e){let t;return e.rpcMap&&(t=e.rpcMap[_([s])]),t}function _(s){return Number(s[0].split(":")[1])}class b{constructor(e){this.name="eip155",this.namespace=e.namespace,this.client=e.client,this.events=e.events,this.httpProviders=this.createHttpProviders(),this.chainId=this.getDefaultChainId()}async request(e){var t;switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":{const i=e.request.params?(t=e.request.params[0])==null?void 0:t.chainId:"0x0";return this.setDefaultChain(parseInt(i,16).toString()),null}case"eth_chainId":return this.getDefaultChainId()}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,t){if(this.chainId=parseInt(e),!this.httpProviders[e]){const i=t||a(`${this.name}:${e}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.events.emit("chainChanged",this.chainId)}createHttpProvider(e,t){const i=t||a(e,this.namespace);return typeof i>"u"?void 0:new p.JsonRpcProvider(new l.HttpConnection(i))}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}getDefaultChainId(){if(this.chainId)return this.chainId;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return parseInt(e.split(":")[1])}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}}class S{constructor(e){this.name="solana",this.namespace=e.namespace,this.events=e.events,this.client=e.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getDefaultChainId(){if(this.chainId)return this.chainId;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const i=t||a(`${this.name}:${e}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.events.emit("chainChanged",this.chainId)}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||a(e,this.namespace);return typeof i>"u"?void 0:new p.JsonRpcProvider(new O.default(i))}}const d="error",$="wss://relay.walletconnect.com",j="wc",H="universal_provider",u=`${j}@${2}:${H}:`;var N=Object.defineProperty,D=Object.defineProperties,k=Object.getOwnPropertyDescriptors,v=Object.getOwnPropertySymbols,R=Object.prototype.hasOwnProperty,U=Object.prototype.propertyIsEnumerable,g=(s,e,t)=>e in s?N(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,m=(s,e)=>{for(var t in e||(e={}))R.call(e,t)&&g(s,t,e[t]);if(v)for(var t of v(e))U.call(e,t)&&g(s,t,e[t]);return s},A=(s,e)=>D(s,k(e));class o{constructor(e){this.events=new E.default,this.rpcProviders={},this.providerOpts=e,this.logger=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:C.default(P.getDefaultLoggerOptions({level:e?.logger||d}))}static async init(e){const t=new o(e);return await t.initialize(),t}async request(e,t){var i;const[n,c]=this.validateChain(t);return await this.getProvider(n).request({request:m({},e),chainId:`${n}:${c}`,topic:(i=this.session)==null?void 0:i.topic})}sendAsync(e,t,i){this.request(e,i).then(n=>t(null,n)).catch(n=>t(n,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return await this.request({method:"eth_requestAccounts",params:[]})}async disconnect(){if(!this.client)throw new Error("Sign Client not initialized");await this.client.disconnect({topic:this.session.topic,reason:h.getSdkError("USER_DISCONNECTED")})}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");return this.setNamespaces(e.namespaces),this.createProviders(),await this.cleanupPendingPairings(),e.skipPairing===!0?void 0:await this.pair(e.pairingTopic)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}removeListener(e,t){this.events.removeListener(e,t)}off(e,t){this.events.off(e,t)}get isWalletConnect(){return!0}async pair(e){const{uri:t,approval:i}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces});return t&&(this.uri=t,this.events.emit("display_uri",t)),this.session=await i(),this.onSessionUpdate(),this.session}setDefaultChain(e,t){try{const[i,n]=this.validateChain(e);this.getProvider(i).setDefaultChain(n,t)}catch(i){if(!/Please call connect/.test(i.message))throw i}}async cleanupPendingPairings(){this.logger.info("Cleaning up inactive pairings...");const e=this.client.pairing.getAll({active:!1});!h.isValidArray(e)||(await Promise.all([e.map(t=>this.client.pairing.delete(t.topic,h.getSdkError("USER_DISCONNECTED"))),e.map(t=>this.client.core.relayer.unsubscribe(t.topic)),e.map(t=>this.client.core.expirer.del(t.topic))]),this.logger.info(`Inactive pairings cleared: ${e.length}`))}async checkStorage(){if(this.namespaces=await this.client.core.storage.getItem(`${u}/namespaces`)||{},this.namespaces&&this.createProviders(),this.client.session.length){const e=this.client.session.keys.length-1;this.session=this.client.session.get(this.client.session.keys[e]),this.onSessionUpdate()}}async initialize(){this.logger.trace("Initialized"),await this.createClient(),this.checkStorage(),this.registerEventListeners()}async createClient(){this.client=this.providerOpts.client||await I.default.init({logger:this.providerOpts.logger||d,relayUrl:this.providerOpts.relayUrl||$,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,name:this.providerOpts.name}),this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");Object.keys(this.namespaces).forEach(e=>{switch(e){case"eip155":this.rpcProviders[e]=new b({client:this.client,namespace:this.namespaces[e],events:this.events});break;case"solana":this.rpcProviders[e]=new S({client:this.client,namespace:this.namespaces[e],events:this.events});break}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:t})=>{var i;const{namespaces:n}=t,c=(i=this.client)==null?void 0:i.session.get(e);this.session=A(m({},c),{namespaces:n}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:t})}),this.client.on("session_delete",()=>{this.events.emit("session_delete")})}getProvider(e){if(!this.rpcProviders[e])throw new Error(`Provider not found: ${e}`);return this.rpcProviders[e]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>this.getProvider(e).updateNamespace(this.session.namespaces[e]))}setNamespaces(e){if(!e||!Object.keys(e).length)throw new Error("Namespaces must be not empty");this.client.core.storage.setItem(`${u}/namespaces`,e),this.namespaces=e}validateChain(e){const[t,i]=e?.split(":")||["",""];if(t&&!Object.keys(this.namespaces).includes(t))throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);return!t||!i?q(this.namespaces):[t,i]}}const L=o;exports.UniversalProvider=L,exports.default=o;
//# sourceMappingURL=index.cjs.js.map
