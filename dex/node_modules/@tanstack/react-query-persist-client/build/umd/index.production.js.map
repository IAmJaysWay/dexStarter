{"version":3,"file":"index.production.js","sources":["../../../query-core/build/lib/hydration.mjs","../../../query-persist-client-core/build/lib/persist.mjs","../../src/PersistQueryClientProvider.tsx","../../../query-persist-client-core/build/lib/retryStrategies.mjs"],"sourcesContent":["// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQuery.state);\n  });\n}\n\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate };\n//# sourceMappingURL=hydration.mjs.map\n","import { hydrate, dehydrate } from '@tanstack/query-core';\n\n/**\n * Restores persisted data to the QueryCache\n *  - data obtained from persister.restoreClient\n *  - data is hydrated using hydrateOptions\n * If data is expired, busted, empty, or throws, it runs persister.removeClient\n */\nasync function persistQueryClientRestore({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24,\n  buster = '',\n  hydrateOptions\n}) {\n  try {\n    const persistedClient = await persister.restoreClient();\n\n    if (persistedClient) {\n      if (persistedClient.timestamp) {\n        const expired = Date.now() - persistedClient.timestamp > maxAge;\n        const busted = persistedClient.buster !== buster;\n\n        if (expired || busted) {\n          persister.removeClient();\n        } else {\n          hydrate(queryClient, persistedClient.clientState, hydrateOptions);\n        }\n      } else {\n        persister.removeClient();\n      }\n    }\n  } catch (err) {\n    if (process.env.NODE_ENV !== 'production') {\n      queryClient.getLogger().error(err);\n      queryClient.getLogger().warn('Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.');\n    }\n\n    persister.removeClient();\n  }\n}\n/**\n * Persists data from the QueryCache\n *  - data dehydrated using dehydrateOptions\n *  - data is persisted using persister.persistClient\n */\n\nasync function persistQueryClientSave({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions\n}) {\n  const persistClient = {\n    buster,\n    timestamp: Date.now(),\n    clientState: dehydrate(queryClient, dehydrateOptions)\n  };\n  await persister.persistClient(persistClient);\n}\n/**\n * Subscribe to QueryCache and MutationCache updates (for persisting)\n * @returns an unsubscribe function (to discontinue monitoring)\n */\n\nfunction persistQueryClientSubscribe(props) {\n  const unsubscribeQueryCache = props.queryClient.getQueryCache().subscribe(() => {\n    persistQueryClientSave(props);\n  });\n  const unusbscribeMutationCache = props.queryClient.getMutationCache().subscribe(() => {\n    persistQueryClientSave(props);\n  });\n  return () => {\n    unsubscribeQueryCache();\n    unusbscribeMutationCache();\n  };\n}\n/**\n * Restores persisted data to QueryCache and persists further changes.\n */\n\nfunction persistQueryClient(props) {\n  let hasUnsubscribed = false;\n  let persistQueryClientUnsubscribe;\n\n  const unsubscribe = () => {\n    hasUnsubscribed = true;\n    persistQueryClientUnsubscribe == null ? void 0 : persistQueryClientUnsubscribe();\n  }; // Attempt restore\n\n\n  const restorePromise = persistQueryClientRestore(props).then(() => {\n    if (!hasUnsubscribed) {\n      // Subscribe to changes in the query cache to trigger the save\n      persistQueryClientUnsubscribe = persistQueryClientSubscribe(props);\n    }\n  });\n  return [unsubscribe, restorePromise];\n}\n\nexport { persistQueryClient, persistQueryClientRestore, persistQueryClientSave, persistQueryClientSubscribe };\n//# sourceMappingURL=persist.mjs.map\n","import * as React from 'react'\n\nimport type { PersistQueryClientOptions } from '@tanstack/query-persist-client-core'\nimport { persistQueryClient } from '@tanstack/query-persist-client-core'\nimport type { QueryClientProviderProps } from '@tanstack/react-query'\nimport { QueryClientProvider, IsRestoringProvider } from '@tanstack/react-query'\n\nexport type PersistQueryClientProviderProps = QueryClientProviderProps & {\n  persistOptions: Omit<PersistQueryClientOptions, 'queryClient'>\n  onSuccess?: () => void\n}\n\nexport const PersistQueryClientProvider = ({\n  client,\n  children,\n  persistOptions,\n  onSuccess,\n  ...props\n}: PersistQueryClientProviderProps): JSX.Element => {\n  const [isRestoring, setIsRestoring] = React.useState(true)\n  const refs = React.useRef({ persistOptions, onSuccess })\n\n  React.useEffect(() => {\n    refs.current = { persistOptions, onSuccess }\n  })\n\n  React.useEffect(() => {\n    let isStale = false\n    setIsRestoring(true)\n    const [unsubscribe, promise] = persistQueryClient({\n      ...refs.current.persistOptions,\n      queryClient: client,\n    })\n\n    promise.then(() => {\n      if (!isStale) {\n        refs.current.onSuccess?.()\n        setIsRestoring(false)\n      }\n    })\n\n    return () => {\n      isStale = true\n      unsubscribe()\n    }\n  }, [client])\n\n  return (\n    <QueryClientProvider client={client} {...props}>\n      <IsRestoringProvider value={isRestoring}>{children}</IsRestoringProvider>\n    </QueryClientProvider>\n  )\n}\n","const removeOldestQuery = ({\n  persistedClient\n}) => {\n  const mutations = [...persistedClient.clientState.mutations];\n  const queries = [...persistedClient.clientState.queries];\n  const client = { ...persistedClient,\n    clientState: {\n      mutations,\n      queries\n    }\n  }; // sort queries by dataUpdatedAt (oldest first)\n\n  const sortedQueries = [...queries].sort((a, b) => a.state.dataUpdatedAt - b.state.dataUpdatedAt); // clean oldest query\n\n  if (sortedQueries.length > 0) {\n    const oldestData = sortedQueries.shift();\n    client.clientState.queries = queries.filter(q => q !== oldestData);\n    return client;\n  }\n\n  return undefined;\n};\n\nexport { removeOldestQuery };\n//# sourceMappingURL=retryStrategies.mjs.map\n"],"names":["defaultShouldDehydrateMutation","mutation","state","isPaused","defaultShouldDehydrateQuery","query","status","dehydrate","client","options","mutations","queries","dehydrateMutations","shouldDehydrateMutation","getMutationCache","getAll","forEach","push","mutationKey","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","getQueryCache","queryKey","queryHash","dehydrateQuery","async","persistQueryClientRestore","queryClient","persister","maxAge","buster","hydrateOptions","persistedClient","restoreClient","timestamp","expired","Date","now","busted","removeClient","dehydratedState","mutationCache","queryCache","dehydratedMutation","_options$defaultOptio","build","defaultOptions","dehydratedQuery","_options$defaultOptio2","get","dataUpdatedAt","setState","hydrate","clientState","err","persistQueryClientSave","dehydrateOptions","persistClient","persistQueryClientSubscribe","props","unsubscribeQueryCache","subscribe","unusbscribeMutationCache","persistQueryClient","persistQueryClientUnsubscribe","hasUnsubscribed","then","children","persistOptions","onSuccess","isRestoring","setIsRestoring","React","useState","refs","useRef","useEffect","current","isStale","unsubscribe","promise","QueryClientProvider","_extends","createElement","IsRestoringProvider","value","sortedQueries","sort","a","b","length","oldestData","shift","filter","q"],"mappings":"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"}