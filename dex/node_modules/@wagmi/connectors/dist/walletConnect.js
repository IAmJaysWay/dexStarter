import {
  Connector,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-5NCTPR6C.js";

// src/walletConnect.ts
import {
  SwitchChainError,
  UserRejectedRequestError,
  getClient,
  normalizeChainId
} from "@wagmi/core";
import { providers } from "ethers";
import { getAddress, hexValue } from "ethers/lib/utils.js";
var defaultV2Config = {
  namespace: "eip155",
  methods: [
    "eth_sendTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "personal_sign"
  ],
  events: ["accountsChanged", "chainChanged"]
};
var _provider, _universalProviderPromise, _web3Modal, _createWeb3Modal, createWeb3Modal_fn, _getUniversalProvider, getUniversalProvider_fn, _isChainsAuthorized, isChainsAuthorized_fn, _switchChain, switchChain_fn;
var WalletConnectConnector = class extends Connector {
  constructor(config) {
    super(config);
    __privateAdd(this, _createWeb3Modal);
    __privateAdd(this, _getUniversalProvider);
    __privateAdd(this, _isChainsAuthorized);
    __privateAdd(this, _switchChain);
    __publicField(this, "id", "walletConnect");
    __publicField(this, "name", "WalletConnect");
    __publicField(this, "ready", true);
    __privateAdd(this, _provider, void 0);
    __privateAdd(this, _universalProviderPromise, void 0);
    __privateAdd(this, _web3Modal, void 0);
    __publicField(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: getAddress(accounts[0]) });
    });
    __publicField(this, "onChainChanged", (chainId) => {
      const id = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id);
      this.emit("change", { chain: { id, unsupported } });
    });
    __publicField(this, "onDisconnect", () => {
      this.emit("disconnect");
    });
    __publicField(this, "onDisplayUri", (uri) => {
      this.emit("message", { type: "display_uri", data: uri });
    });
    if (this.version === "2") {
      __privateMethod(this, _getUniversalProvider, getUniversalProvider_fn).call(this);
      if (this.isQrCode)
        __privateMethod(this, _createWeb3Modal, createWeb3Modal_fn).call(this);
    }
  }
  get isQrCode() {
    return this.options.qrcode !== false;
  }
  get namespacedChains() {
    return this.chains.map(
      (chain) => `${defaultV2Config.namespace}:${chain.id}`
    );
  }
  get version() {
    if ("version" in this.options)
      return this.options.version;
    return "1";
  }
  async connect({ chainId } = {}) {
    const isV1 = this.version === "1";
    const isV2 = this.version === "2";
    try {
      let targetChainId = chainId;
      if (!targetChainId) {
        const lastUsedChainId = getClient().lastUsedChainId;
        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId))
          targetChainId = lastUsedChainId;
      }
      const provider = await this.getProvider({
        chainId: targetChainId,
        create: isV1
      });
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      if (isV2) {
        provider.on("session_delete", this.onDisconnect);
        provider.on("display_uri", this.onDisplayUri);
        const isChainsAuthorized = await __privateMethod(this, _isChainsAuthorized, isChainsAuthorized_fn).call(this);
        if (provider.session && !isChainsAuthorized)
          await provider.disconnect();
        if (!provider.session || provider.session && !isChainsAuthorized) {
          await Promise.race([
            provider.connect({
              namespaces: {
                [defaultV2Config.namespace]: {
                  methods: defaultV2Config.methods,
                  events: defaultV2Config.events,
                  chains: this.namespacedChains,
                  rpcMap: this.chains.reduce(
                    (rpc, chain) => ({
                      ...rpc,
                      [chain.id]: chain.rpcUrls.default.http[0]
                    }),
                    {}
                  )
                }
              }
            }),
            ...this.isQrCode ? [
              new Promise(
                (_resolve, reject) => provider.on("display_uri", async (uri) => {
                  await __privateGet(this, _web3Modal)?.openModal({ uri });
                  __privateGet(this, _web3Modal)?.subscribeModal(({ open }) => {
                    if (!open)
                      reject(new Error("user rejected"));
                  });
                })
              )
            ] : []
          ]);
          if (this.isQrCode)
            __privateGet(this, _web3Modal)?.closeModal();
        }
      }
      setTimeout(() => this.emit("message", { type: "connecting" }), 0);
      const accounts = await Promise.race([
        provider.enable(),
        ...isV1 && this.isQrCode ? [
          new Promise(
            (_res, reject) => provider.connector.on(
              "disconnect",
              () => reject(new Error("user rejected"))
            )
          )
        ] : []
      ]);
      const account = getAddress(accounts[0]);
      const id = await this.getChainId();
      const unsupported = this.isChainUnsupported(id);
      if (isV1) {
        const walletName = provider.connector?.peerMeta?.name ?? "";
        const switchChainAllowedRegex = /(imtoken|metamask|omni|rainbow|trust wallet)/i;
        if (switchChainAllowedRegex.test(walletName))
          this.switchChain = __privateMethod(this, _switchChain, switchChain_fn);
      } else
        this.switchChain = __privateMethod(this, _switchChain, switchChain_fn);
      return {
        account,
        chain: { id, unsupported },
        provider: new providers.Web3Provider(
          provider
        )
      };
    } catch (error) {
      if (isV2 && this.isQrCode)
        __privateGet(this, _web3Modal)?.closeModal();
      if (/user closed modal|user rejected/i.test(
        error?.message
      )) {
        throw new UserRejectedRequestError(error);
      }
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    try {
      await provider.disconnect();
    } catch (error) {
      if (!/No matching key/i.test(error.message))
        throw error;
    }
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    if (this.version === "1" && typeof localStorage !== "undefined")
      localStorage.removeItem("walletconnect");
    else {
      provider.removeListener("session_delete", this.onDisconnect);
      provider.removeListener("display_uri", this.onDisplayUri);
    }
  }
  async getAccount() {
    const provider = await this.getProvider();
    let accounts;
    if (this.version === "1")
      accounts = provider.accounts;
    else
      accounts = await provider.request({
        method: "eth_accounts"
      });
    return getAddress(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    if (this.version === "1")
      return normalizeChainId(provider.chainId);
    return getClient().data?.chain?.id ?? normalizeChainId(await provider.request({ method: "eth_chainId" }));
  }
  async getProvider({
    chainId,
    create
  } = {}) {
    if (this.options.version === "2") {
      if (!__privateGet(this, _provider) || create)
        __privateSet(this, _provider, await __privateMethod(this, _getUniversalProvider, getUniversalProvider_fn).call(this));
      if (chainId)
        __privateGet(this, _provider).setDefaultChain(
          `${defaultV2Config.namespace}:${chainId}`
        );
      return __privateGet(this, _provider);
    } else if (!__privateGet(this, _provider) || chainId || create) {
      const rpc = !this.options?.infuraId ? this.chains.reduce(
        (rpc2, chain) => ({
          ...rpc2,
          [chain.id]: chain.rpcUrls.default.http[0]
        }),
        {}
      ) : {};
      const WalletConnectProvider = (await import("@walletconnect/ethereum-provider")).default;
      __privateSet(this, _provider, new WalletConnectProvider({
        ...this.options,
        chainId,
        rpc: { ...rpc, ...this.options?.rpc }
      }));
      return __privateGet(this, _provider);
    }
    return __privateGet(this, _provider);
  }
  async getSigner({ chainId } = {}) {
    const [provider, account] = await Promise.all([
      this.getProvider({ chainId }),
      this.getAccount()
    ]);
    let provider_ = provider;
    if (this.version === "2") {
      const chainId_ = await this.getChainId();
      provider_ = {
        ...provider,
        async request(args) {
          return await provider.request(
            args,
            `${defaultV2Config.namespace}:${chainId ?? chainId_}`
          );
        }
      };
    }
    return new providers.Web3Provider(provider_, chainId).getSigner(account);
  }
  async isAuthorized() {
    try {
      const [account, isChainsAuthorized] = await Promise.all([
        this.getAccount(),
        __privateMethod(this, _isChainsAuthorized, isChainsAuthorized_fn).call(this)
      ]);
      return !!account && isChainsAuthorized;
    } catch {
      return false;
    }
  }
};
_provider = new WeakMap();
_universalProviderPromise = new WeakMap();
_web3Modal = new WeakMap();
_createWeb3Modal = new WeakSet();
createWeb3Modal_fn = async function() {
  const { Web3Modal } = await import("@web3modal/standalone");
  const { version } = this.options;
  __privateSet(this, _web3Modal, new Web3Modal({
    projectId: version === "2" ? this.options.projectId : void 0,
    standaloneChains: this.namespacedChains
  }));
};
_getUniversalProvider = new WeakSet();
getUniversalProvider_fn = async function() {
  if (!__privateGet(this, _universalProviderPromise)) {
    const WalletConnectProvider = (await import("@walletconnect/universal-provider")).default;
    __privateSet(this, _universalProviderPromise, WalletConnectProvider.init(
      this.options
    ));
  }
  return __privateGet(this, _universalProviderPromise);
};
_isChainsAuthorized = new WeakSet();
isChainsAuthorized_fn = async function() {
  const provider = await this.getProvider();
  if (this.version === "1")
    return true;
  const providerChains = provider.namespaces?.[defaultV2Config.namespace]?.chains || [];
  const authorizedChainIds = providerChains.map(
    (chain) => parseInt(chain.split(":")[1] || "")
  );
  return !this.chains.some(({ id }) => !authorizedChainIds.includes(id));
};
_switchChain = new WeakSet();
switchChain_fn = async function(chainId) {
  const provider = await this.getProvider();
  const id = hexValue(chainId);
  try {
    await Promise.race([
      provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: id }]
      }),
      new Promise(
        (res) => this.on("change", ({ chain }) => {
          if (chain?.id === chainId)
            res(chainId);
        })
      )
    ]);
    if (this.version === "2") {
      ;
      provider.setDefaultChain(
        `${defaultV2Config.namespace}:${chainId}`
      );
      this.onChainChanged(chainId);
    }
    return this.chains.find((x) => x.id === chainId) ?? {
      id: chainId,
      name: `Chain ${id}`,
      network: `${id}`,
      nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
      rpcUrls: { default: { http: [""] } }
    };
  } catch (error) {
    const message = typeof error === "string" ? error : error?.message;
    if (/user rejected request/i.test(message))
      throw new UserRejectedRequestError(error);
    throw new SwitchChainError(error);
  }
};
export {
  WalletConnectConnector
};
